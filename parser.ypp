%{
    #include "parser.h"
%}

%token            VOID
%token            INT
%token            BYTE
%token            B
%token            BOOL
%left             OR
%left             AND
%right            NOT
%token            TRUE
%token            FALSE
%token            RETURN
%token            IF
%token            ELSE
%token            WHILE
%token            BREAK
%token            CONTINUE
%token            PRECOND
%token            SC
%token            COMMA
%token            LPAREN
%token            RPAREN
%token            LBRACE
%token            RBRACE
%right            ASSIGN
%left             RELOP
%left             BINOP
%token            ID
%token            NUM
%token            STRING
%token            EF

%%

Program	:	Funcs EF
        { verifyMainFunction();
          exit_last_scope();}
        ;

Funcs	:	/*epsilon*/
		|	FuncDecl Funcs
	    ;

FuncDecl	:	RetType ID LPAREN {new_scope();} Formals RPAREN PreConditions {endScope(); condPrintWrapper($2, $7);} LBRACE Statements RBRACE
            {
                TypesList* ret_types = dynamic_cast<TypesList*>($10);
                if(ret_types != NULL){
                    if(!all_ret_same(ret_types->params)){
                        WRAP_ERROR(errorMismatch(yylineno));
                    }
                }
                int ret_type_from_statement = get_ret_from_statements(ret_types);
                int ret_type_num = static_cast<Type*>($1)->type;
                tokens ret_type = static_cast<tokens>(ret_type_num);
                if(!compare_types(ret_type_from_statement, ret_type_num)){
                    WRAP_ERROR(errorMismatch(yylineno));
                }
                string id = static_cast<Id*>($2)->id;
                TypesList* func_params = static_cast<TypesList*>($5);
                add_func(func_params->params, ret_type, id);
                int pre_num = static_cast<Preconditions*>($7)->preconditions_num;
                exit_scope(true);
            }
	        ;

RetType	:	Type
            { $$ = new Type(static_cast<Type*>($1)->type); }

		|	VOID
		    { $$ = new Type(VOID); }
	    ;

Formals	:	/*epsilon*/
        { $$ = new TypesList(); }

		|	FormalsList
		{
            $$ = new TypesList();
            vector<int>& params = static_cast<TypesList*>($$)->params;
            vector<int>& params_other = static_cast<TypesList*>($1)->params;
            params = params_other;
		}
	    ;

FormalsList	:	FormalDecl
            {
                $$ = new TypesList();
                Type* t = static_cast<Type*>($1);
                static_cast<TypesList*>($$)->params.push_back(t->type);
            }
			|	FormalDecl COMMA FormalsList
			{
                $$ = new TypesList();
                vector<int>& params = static_cast<TypesList*>($$)->params;
                vector<int>& params_other = static_cast<TypesList*>($3)->params;
                params.push_back(static_cast<Type*>($1)->type);
                params.insert(params.end(), params_other.begin(), params_other.end());
			}
			;

FormalDecl	:	Type ID
            {
                tryAddVariable($1, $2, true);
                $$ = new Type(static_cast<Type*>($1)->type);
	        }
            ;
PreConditions	:	/*epsilon*/ {$$ = new Preconditions(0);}
				|	PreConditions PreCondition
				{
				 int num = static_cast<Preconditions*>($1)->preconditions_num;
				 $$ = new Preconditions(num + 1);
				}
	            ;

PreCondition	:	PRECOND LPAREN Exp RPAREN
                    { verifyType($3, BOOL); }
	            ;

Statements	:	Statement
            {
                TypesList* t = dynamic_cast<TypesList*>($1);
                if(t != NULL){
                    $$ = new TypesList(t->params);
                }
            }
			|	Statements Statement
                {
                    TypesList* t1 = dynamic_cast<TypesList*>($1);
                    TypesList* t2 = dynamic_cast<TypesList*>($2);
                    if(t1 != NULL || t2 != NULL){
                        $$ = new TypesList();
                        concatenate_params(dynamic_cast<TypesList*>($$)->params, t1, t2);
                    }
                }
	        ;

Statement: Open_statement
           {
                TypesList* t = dynamic_cast<TypesList*>($1);
                if(t != NULL){
                    $$ = new TypesList(t->params);
                }
           }
         | Closed_statement
           {
                TypesList* t = dynamic_cast<TypesList*>($1);
                if(t != NULL){
                    $$ = new TypesList(t->params);
                }
           }
         ;

Open_statement: IF LPAREN Exp RPAREN Simple_statement
                {
                    verifyType($3, BOOL);
                    TypesList* t = dynamic_cast<TypesList*>($5);
                    if(t != NULL){
                        $$ = new TypesList(t->params);
                    }
                }

              | IF LPAREN Exp RPAREN Open_statement
                {
                    verifyType($3, BOOL);
                    TypesList* t = dynamic_cast<TypesList*>($5);
                    if(t != NULL){
                        $$ = new TypesList(t->params);
                    }
                }

              | IF LPAREN Exp RPAREN Closed_statement ELSE Open_statement
                {
                    verifyType($3, BOOL);
                    TypesList* t1 = dynamic_cast<TypesList*>($5);
                    TypesList* t2 = dynamic_cast<TypesList*>($7);
                    if(t1 != NULL || t2 != NULL){
                        $$ = new TypesList();
                        concatenate_params(dynamic_cast<TypesList*>($$)->params, t1, t2);
                    }
                }

              | WHILE {in_while = true;} LPAREN Exp RPAREN {in_while = false;} Open_statement
                {
                    verifyType($3, BOOL);
                    TypesList* t = dynamic_cast<TypesList*>($7);
                    if(t != NULL){
                        $$ = new TypesList(t->params);
                    }
                }
              ;

Closed_statement: Simple_statement
                | IF LPAREN Exp RPAREN Closed_statement ELSE Closed_statement
                  {
                    verifyType($3, BOOL);
                    TypesList* t1 = dynamic_cast<TypesList*>($5);
                    TypesList* t2 = dynamic_cast<TypesList*>($7);
                    if(t1 != NULL || t2 != NULL){
                        $$ = new TypesList();
                        concatenate_params(dynamic_cast<TypesList*>($$)->params, t1, t2);
                    }
                  }

                | WHILE LPAREN {in_while = true;} Exp RPAREN {in_while = false;} Closed_statement
                  {
                    verifyType($3, BOOL);
                    TypesList* t1 = dynamic_cast<TypesList*>($7);
                    if(t1 != NULL){
                         $$ = new TypesList(t1->params);
                    }
                  }
                ;

Simple_statement: LBRACE Statements RBRACE
                  {
                   TypesList* t = dynamic_cast<TypesList*>($2);
                   if(t != NULL){
                        $$ = new TypesList(t->params);
                   }
                  }

                | Type ID SC
                  {tryAddVariable($1, $2, false);}

                | Type ID ASSIGN Exp SC
                  {tryAddVariable($1, $2, false);
                   Type* t = static_cast<Type*>($1);}

                | ID ASSIGN Exp SC
                | Call SC
                | RETURN SC
                {
                 int type = static_cast<int>(VOID);
                 vector<int> v = {type};
                   $$ = new TypesList(v);
                }
                | RETURN Exp SC
                {
                 int type = static_cast<Type*>($2)->type;
                 vector<int> v = {type};
                 $$ = new TypesList(v);
                }
                | BREAK SC
                {
                    if (!in_while) {
                        errorUnexpectedBreak(yylineno);
                    }
                    $$ = new Type(static_cast<int>(VOID));
                }
                | CONTINUE SC
                {
                    if (!in_while) {
                        errorUnexpectedContinue(yylineno);
                    }
                }
                ;

Call	:	ID LPAREN ExpList RPAREN
            {
                verifyFunctionDefined($1);
                $$ = new Type(getFunctionReturnType($1));
                verifyRightParams($1, $3);
            }

		|	ID LPAREN RPAREN
		    {
		        $$ = new Type(getFunctionReturnType($1));
		        verifyFunctionDefined($1);
		        TypesList* empty = new TypesList();
                verifyRightParams($1, empty);
		    }
	    ;

ExpList	:	Exp
        {
         int type = static_cast<Type*>($1)->type;
         vector<int> v = {type};
         $$ = new TypesList(v);
        }
		|	Exp COMMA ExpList
		{
		 int type = static_cast<Type*>($1)->type;
         $$ = new TypesList({type});
         vector<int>& v = static_cast<TypesList*>($$)->params;
         vector<int>& exp = static_cast<TypesList*>($3)->params;
         v.insert(v.end(), exp.begin(), exp.end());
		}
	    ;

Type	:	INT
        { $$ = new Type(INT); }

		|	BYTE
		{ $$ = new Type(BYTE); }

		|	BOOL
		{ $$ = new Type(BOOL); }
	    ;

Exp	:	LPAREN Exp RPAREN
    { $$ = new Type(static_cast<Type*>($2)->type); }

	|	Exp BINOP Exp
	{
        int t1 = verifyTypes($1, 3, NUM, BYTE, INT);
        int t2 = verifyTypes($3, 3, NUM, BYTE, INT);

        // Try NUM precision first, retreat to byte if both are BYTE
        int preciseType = t1 == NUM ? NUM : (t2 == NUM ? NUM : BYTE);
        $$ = new Type(preciseType);
    }

	|	ID
    {
        verifyVariableDefined($1);
        $$ = new Type(getVariableType($1));
    }

	|	Call
	{ $$ = $1; }

	|	NUM
	{ $$ = new Type(NUM); }

	|	NUM B
	{
	    verifyByteSize($1);
	    $$ = new Type(BYTE);
	}

	|	STRING
	{ $$ = new Type(STRING); }

	|	TRUE
	{ $$ = new Type(BOOL); }

	|	FALSE
	{ $$ = new Type(BOOL); }

	|	NOT Exp
	{
    	verifyType($2, BOOL);
        $$ = new Type(BOOL);
    }
	|	Exp AND Exp
	{
	    verifyType($1, BOOL);
	    verifyType($3, BOOL);
        $$ = new Type(BOOL);
    }
	|	Exp OR Exp
	{
	    verifyType($1, BOOL);
     	verifyType($3, BOOL);
        $$ = new Type(BOOL);
    }
	|	Exp RELOP Exp
	{
	    verifyTypes($1, 3, NUM, BYTE, INT);
	    verifyTypes($3, 3, NUM, BYTE, INT);
	    $$ = new Type(BOOL);
	}
	;

%%

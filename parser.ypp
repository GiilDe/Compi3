%{
    #include <iostream>
    #include <stdlib.h>
    #include <stdio.h>
    #include "source.hpp"
    #include "cmake-build-debug-cygwin/parser.tab.hpp"
    #include <vector>
    #include <stack>
    #include <unordered_map>
    #include <string>
    #define tokens yytokentype

    #define YYERROR_VERBOSE 1
    #define ScopeTable unordered_map<string, var_data>
    #define FuncTable unordered_map<string, func_data>

    using namespace std;

    struct var_data{
        tokens type;
        int offset;
    };

    struct func_data{
        vector<int> param_types;
        tokens ret_type;
    };

    vector<ScopeTable> scopes_tables;
    stack<int> offsets_stack;
    FuncTable func_table;

    int main();
    int yyerror(const char* message);

    int func_param_offset;
    bool add_var(stack_data* type_class, stack_data* id_class, bool func_var);
    bool add_func(vector<int> param_types, tokens ret_type, string name);
    bool contains_var(string& name);
    void new_scope();
    void exit_scope();

    extern int yylex();
%}

%token            VOID
%token            INT
%token            BYTE
%token            B
%token            BOOL
%left             OR
%left             AND
%right            NOT
%token            TRUE
%token            FALSE
%token            RETURN
%token            IF
%token            ELSE
%token            WHILE
%token            BREAK
%token            CONTINUE
%token            PRECOND
%token            SC
%token            COMMA
%token            LPAREN
%token            RPAREN
%token            LBRACE
%token            RBRACE
%right            ASSIGN
%left             RELOP
%left             BINOP
%token            ID
%token            NUM
%token            STRING

%%

Program	:	Funcs
        ;

Funcs	:	/*epsilon*/
		|	FuncDecl Funcs
	    ;

FuncDecl	:	RetType ID LPAREN {new_scope();} Formals RPAREN PreConditions LBRACE Statements RBRACE
            {
            tokens ret_type = static_cast<tokens>(static_cast<Type*>($1)->type);
            string id = static_cast<Id*>($2)->id;
            ParamsList* l = static_cast<ParamsList*>($5);
            add_func(l->params, ret_type, id);
            }
	        ;

RetType	:	Type
            {
            $$ = new Type();
            Type* t = static_cast<Type*>($1);
            static_cast<Type*>($$)->type = static_cast<int>(t->type);
            }
		|	VOID
		    {
		    $$ = new Type();
		    static_cast<Type*>($$)->type = static_cast<int>(VOID);
		    }
	    ;

Formals	:	/*epsilon*/
        {
        $$ = new ParamsList();
        }
		|	FormalsList
		{
		$$ = new ParamsList();
        vector<int>& params = static_cast<ParamsList*>($$)->params;
        vector<int>& params_other = static_cast<ParamsList*>($1)->params;
        params = params_other;
		}
	    ;

FormalsList	:	FormalDecl
            {
            $$ = new ParamsList();
            Type* t = static_cast<Type*>($1);
            static_cast<ParamsList*>($$)->params.push_back(t->type);
            }
			|	FormalDecl COMMA FormalsList
			{
			$$ = new ParamsList();
            vector<int>& params = static_cast<ParamsList*>($$)->params;
            vector<int>& params_other = static_cast<ParamsList*>($3)->params;
            params.push_back(static_cast<Type*>($1)->type);
			params.insert(params.end(), params_other.begin(), params_other.end());
			}
			;

FormalDecl	:	Type ID
            {
              if(!add_var($1, $2, true)){
                    yyerror("variable already defined");
              }
              $$ = new Type();
              static_cast<Type*>($$)->type = static_cast<Type*>($1)->type;
	        }
            ;
PreConditions	:	/*epsilon*/
				|	PreConditions PreCondition
	            ;

PreCondition	:	PRECOND LPAREN Exp RPAREN
	            ;

Statements	:	Statement
			|	Statements Statement
	        ;

Statement: Open_statement
         | Closed_statement
         ;

Open_statement: IF LPAREN Exp RPAREN Simple_statement
              | IF LPAREN Exp RPAREN Open_statement
              | IF LPAREN Exp RPAREN Closed_statement ELSE Open_statement
              | WHILE LPAREN Exp RPAREN Open_statement
              ;

Closed_statement: Simple_statement
                | IF LPAREN Exp RPAREN Closed_statement ELSE Closed_statement
                | WHILE LPAREN Exp RPAREN Closed_statement
                ;

Simple_statement: LBRACE {new_scope();} Statements RBRACE
                | Type ID SC
                {
                  if(!add_var($1, $2, false)){
                        yyerror("variable already defined");
                  }
                }
                | Type ID ASSIGN Exp SC
                {
                  if(!add_var($1, $2, false)){
                        yyerror("variable already defined");
                  }
                }
                | ID ASSIGN Exp SC
                | Call SC
                | RETURN SC
                | RETURN Exp SC
                | BREAK SC
                | CONTINUE SC
                ;

Call	:	ID LPAREN ExpList RPAREN
		|	ID LPAREN RPAREN
	    ;

ExpList	:	Exp
		|	Exp COMMA ExpList
	    ;

Type	:	INT
		|	BYTE
		|	BOOL
	    ;

Exp	:	LPAREN Exp RPAREN
	|	Exp BINOP Exp
	|	ID
	|	Call
	|	NUM
	|	NUM B
	|	STRING
	|	TRUE
	|	FALSE
	|	NOT Exp
	|	Exp AND Exp
	|	Exp OR	Exp
	|	Exp RELOP Exp
	;

%%

void exit_scope(){
    offsets_stack.pop();
    scopes_tables.pop_back();
}

void new_scope(){
    func_param_offset = -1;
    offsets_stack.push(offsets_stack.top());
    scopes_tables.push_back(ScopeTable());
}

bool contains_var(string& name){
    for(ScopeTable& t : scopes_tables){
        if(t.find(name) != t.end()){
            return true;
        }
    }
    return false;
}

bool add_var(stack_data* type_class, stack_data* id_class, bool func_var){
    Type* conv1 = static_cast<Type*>(type_class);
    Id* conv2 = static_cast<Id*>(id_class);

    tokens type = static_cast<tokens>(conv1->type);
    string name = conv2->id;

    if(contains_var(name) || func_table.find(name) != func_table.end()){
        return false;
    }
    int* offset;
    if(func_var)
        offset = &func_param_offset;
    else
        offset = &offsets_stack.top();
    var_data sd = {type, *offset};
    ScopeTable& t = scopes_tables.back();
    t.insert({name, sd});
    if(func_var)
        (*offset)--;
    else
        (*offset)++;
    return true;
}

bool add_func(vector<int> param_types, tokens ret_type, string name){
    func_data fd = {param_types, ret_type};
    if(func_table.find(name) != func_table.end()){
        return false;
    }
    func_table.insert({name, fd});
    return true;
}

int yyerror(const char* message){
	cout << "Parse error: " << message << endl;
	exit(5);
}

int main(){
    func_param_offset = -1;
    offsets_stack.push(0);
    #ifdef YYDEBUG
        yydebug = 1;
    #endif
    return yyparse();
}


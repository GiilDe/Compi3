%{
    #include <iostream>
    #include <stdlib.h>
    #include <stdio.h>
    #include "source.hpp"
    #include "cmake-build-debug-cygwin/parser.tab.hpp"
    #include <vector>
    #include <stack>
    #include <unordered_map>
    #include <string>
    #define tokens yytokentype

    #define YYERROR_VERBOSE 1
    #define ScopeTable unordered_map<string, var_data>
    #define FuncTable unordered_map<string, func_data>

    using namespace std;

    struct var_data{
        tokens type;
        int offset;
    };

    struct func_data{
        vector<tokens> param_types;
        tokens ret_type;
    };

    vector<ScopeTable> scopes_tables;
    stack<int> offsets_stack;
    FuncTable func_table;

    int main();
    int yyerror(const char* message);

    bool add_var(tokens type, string name);
    bool add_func(vector<tokens> param_types, tokens ret_type, string name);
    bool contains_var(string& name);
    void new_scope();
    void exit_scope();

    extern int yylex();
%}

%token            VOID
%token            INT
%token            BYTE
%token            B
%token            BOOL
%left             OR
%left             AND
%right            NOT
%token            TRUE
%token            FALSE
%token            RETURN
%token            IF
%token            ELSE
%token            WHILE
%token            BREAK
%token            CONTINUE
%token            PRECOND
%token            SC
%token            COMMA
%token            LPAREN
%token            RPAREN
%token            LBRACE
%token            RBRACE
%right            ASSIGN
%left             RELOP
%left             BINOP
%token            ID
%token            NUM
%token            STRING

%%

Program	:	Funcs
        ;

Funcs	:	/*epsilon*/
		|	FuncDecl Funcs
	    ;

FuncDecl	:	RetType ID LPAREN {new_scope();} Formals RPAREN PreConditions LBRACE Statements RBRACE
            {
            tokens type = static_cast<tokens>(static_cast<Type*>($1)->type);
            string id = static_cast<Id*>($1)->id;
            }
	        ;

RetType	:	Type
            {
            $$ = new Type();
            static_cast<Type*>($$)->type = static_cast<int>(VOID);
            }
		|	VOID
		    {
		    $$ = new Type();
		    static_cast<Type*>($$)->type = static_cast<int>(VOID);
		    }
	    ;

Formals	:	/*epsilon*/
		|	FormalsList
	    ;

FormalsList	:	FormalDecl
			|	FormalDecl COMMA FormalsList ;

FormalDecl	:	Type ID
	        ;

PreConditions	:	/*epsilon*/
				|	PreConditions PreCondition
	            ;

PreCondition	:	PRECOND LPAREN Exp RPAREN
	            ;

Statements	:	Statement
			|	Statements Statement
	        ;

Statement: Open_statement
         | Closed_statement
         ;

Open_statement: IF LPAREN Exp RPAREN Simple_statement
              | IF LPAREN Exp RPAREN Open_statement
              | IF LPAREN Exp RPAREN Closed_statement ELSE Open_statement
              | WHILE LPAREN Exp RPAREN Open_statement
              ;

Closed_statement: Simple_statement
                | IF LPAREN Exp RPAREN Closed_statement ELSE Closed_statement
                | WHILE LPAREN Exp RPAREN Closed_statement
                ;

Simple_statement: LBRACE {new_scope();} Statements RBRACE
                | Type ID SC
                {
                  Type* conv1 = static_cast<Type*>($1);
                  Id* conv2 = static_cast<Id*>($2);
                  if(!add_var(static_cast<tokens>(conv1->type), conv2->id)){
                        yyerror("variable already defined");
                  }
                }
                | Type ID ASSIGN Exp SC
                {
                  Type* conv1 = static_cast<Type*>($1);
                  Id* conv2 = static_cast<Id*>($2);
                  if(!add_var(static_cast<tokens>(conv1->type), conv2->id)){
                        yyerror("variable already defined");
                  }
                }
                | ID ASSIGN Exp SC
                | Call SC
                | RETURN SC
                | RETURN Exp SC
                | BREAK SC
                | CONTINUE SC
                ;

Call	:	ID LPAREN ExpList RPAREN
		|	ID LPAREN RPAREN
	    ;

ExpList	:	Exp
		|	Exp COMMA ExpList
	    ;

Type	:	INT
		|	BYTE
		|	BOOL
	    ;

Exp	:	LPAREN Exp RPAREN
	|	Exp BINOP Exp
	|	ID
	|	Call
	|	NUM
	|	NUM B
	|	STRING
	|	TRUE
	|	FALSE
	|	NOT Exp
	|	Exp AND Exp
	|	Exp OR	Exp
	|	Exp RELOP Exp
	;

%%

void exit_scope(){
    offsets_stack.pop();
    scopes_tables.pop_back();
}

void new_scope(){
    offsets_stack.push(offsets_stack.top());
    scopes_tables.push_back(ScopeTable());
}

bool contains_var(string& name){
    for(ScopeTable& t : scopes_tables){
        if(t.find(name) != t.end()){
            return true;
        }
    }
    return false;
}

bool add_var(tokens type, string name, bool func_var){
    if(contains_var(name) || func_table.find(name) != func_table.end()){
        return false;
    }
    if(!func_var)
        int& offset = offsets_stack.top();
    else
        int offset = offsets_stack.top()-1;
    var_data sd = {type, offset};
    ScopeTable& t = scopes_tables.back();
    t.insert({name, sd});
    if(!func_var)
        offset++;
    return true;
}

bool add_func(vector<tokens> param_types, tokens ret_type, string name){
    func_data fd = {param_types, ret_type};
    if(func_table.find(name) != func_table.end()){
        return false;
    }
    func_table.insert({name, fd});
    return true;
}

int yyerror(const char* message){
	cout << "Parse error: " << message << endl;
	exit(1);
}

int main(){
    offsets_stack.push(0);
    #ifdef YYDEBUG
        yydebug = 1;
    #endif
    return yyparse();
}


%{
    #include <iostream>
    #include <stdlib.h>
    #include <stdio.h>
    #include "source.hpp"
    #include "parser_stuff.hpp"
    #include <vector>
    #include <stack>
    #include <unordered_map>
    #include <string>

    #define YYERROR_VERBOSE 1
    #define ScopeTable unordered_map<string, var_data>
    #define tokens yytokentype
    #define FuncTable unordered_map<string, func_data>

    using namespace std;

    vector<ScopeTable> scopes_tables;
    stack<int> offsets_stack;
    FuncTable func_table;

    int main();
    int yyerror(const char* message);

    bool add_var(tokens type, string name);
    bool add_func(vector<tokens> param_types, tokens ret_type, string name);
    bool contains_var(string& name);
    void new_scope();
    void exit_scope();

    extern int yylex();
%}

%token            VOID
%token            INT
%token            BYTE
%token            B
%token            BOOL
%left             OR
%left             AND
%right            NOT
%token            TRUE
%token            FALSE
%token            RETURN
%token            IF
%token            ELSE
%token            WHILE
%token            BREAK
%token            CONTINUE
%token            PRECOND
%token            SC
%token            COMMA
%token            LPAREN
%token            RPAREN
%token            LBRACE
%token            RBRACE
%right            ASSIGN
%left             RELOP
%left             BINOP
%token            ID
%token            NUM
%token            STRING

%%

Program	:	Funcs
        ;

Funcs	:	/*epsilon*/
		|	FuncDecl Funcs
	    ;

FuncDecl	:	RetType ID LPAREN Formals RPAREN PreConditions LBRACE {new_scope();} Statements RBRACE
	        ;

RetType	:	Type
		|	VOID
	    ;

Formals	:	/*epsilon*/
		|	FormalsList
	    ;

FormalsList	:	FormalDecl
			|	FormalDecl COMMA FormalsList ;

FormalDecl	:	Type ID
	        ;

PreConditions	:	/*epsilon*/
				|	PreConditions PreCondition
	            ;

PreCondition	:	PRECOND LPAREN Exp RPAREN
	            ;

Statements	:	Statement
			|	Statements Statement
	        ;

Statement: Open_statement
         | Closed_statement
         ;

Open_statement: IF LPAREN Exp RPAREN Simple_statement
              | IF LPAREN Exp RPAREN Open_statement
              | IF LPAREN Exp RPAREN Closed_statement ELSE Open_statement
              | WHILE LPAREN Exp RPAREN Open_statement
              ;

Closed_statement: Simple_statement
                | IF LPAREN Exp RPAREN Closed_statement ELSE Closed_statement
                | WHILE LPAREN Exp RPAREN Closed_statement
                ;

Simple_statement: LBRACE {new_scope();} Statements RBRACE
                | Type ID SC
                {
                  stack_data* conv1 = static_cast<stack_data*>($1);
                  stack_data* conv2 = static_cast<stack_data*>($2);
                  if(!add_var(conv1->type, conv2->name)){
                        yyerror("variable already defined");
                  }
                }
                | Type ID ASSIGN Exp SC
                | ID ASSIGN Exp SC
                | Call SC
                | RETURN SC
                | RETURN Exp SC
                | BREAK SC
                | CONTINUE SC
                ;

Call	:	ID LPAREN ExpList RPAREN
		|	ID LPAREN RPAREN
	    ;

ExpList	:	Exp
		|	Exp COMMA ExpList
	    ;

Type	:	INT
		|	BYTE
		|	BOOL
	    ;

Exp	:	LPAREN Exp RPAREN
	|	Exp BINOP Exp
	|	ID
	|	Call
	|	NUM
	|	NUM B
	|	STRING
	|	TRUE
	|	FALSE
	|	NOT Exp
	|	Exp AND Exp
	|	Exp OR	Exp
	|	Exp RELOP Exp
	;

%%

void exit_scope(){
    offsets_stack.pop();
    scopes_tables.pop_back();
}

void new_scope(){
    offsets_stack.push(offsets_stack.top());
    scopes_tables.push_back(ScopeTable());
}

bool contains_var(string& name){
    for(ScopeTable& t : scopes_tables){
        if(t.find(name) != t.end()){
            return true;
        }
    }
    return false;
}

bool add_var(tokens type, string name){
    raise(SIGABRT);
    if(contains_var(name)){
        return false;
    }
    int& offset = offsets_stack.top();
    var_data sd = {type, offset};
    ScopeTable& t = scopes_tables.back();
    t.insert({name, sd});
    offset++;
    return true;
}

bool add_func(vector<tokens> param_types, tokens ret_type, string name){
    func_data fd = {param_types, ret_type};
    if(func_table.find(name) != func_table.end()){
        return false;
    }
    func_table.insert({name, fd});
    return true;
}

int yyerror(const char* message){
	cout << "Parse error: " << message << endl;
	exit(1);
}

int main(){
    raise(SIGABRT);
    offsets_stack.push(0);
    #ifdef YYDEBUG
        yydebug = 1;
    #endif
    return yyparse();
}

